# 타겟 넘버

###### 문제 설명

n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

##### 제한사항

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

##### 입출력 예

| numbers         | target | return |
| --------------- | ------ | ------ |
| [1, 1, 1, 1, 1] | 3      | 5      |

##### 입출력 예 설명

문제에 나온 예와 같습니다.



# 나의 풀이

```python
def solution(numbers, target):
    # 부분집합 구하기를 응용해볼 수 있을 것 같다.
    n = len(numbers)
    cnt = 0
    for i in range(1<<n):
        tmp = []
        for j in range(n):
            if i & (1<<j): # 둘을 자릿수 비교(비트연산)해서 둘 다 1이면
                tmp.append(1)
            else:
                tmp.append(0) # 둘 중 하나라도 1이 아니면
        # for문이 끝나면 1과 0으로 이루어진 하나의 부분집합이 구해진다.
        # 이 작업을 2^n 번 반복하는 코드가 위의 코드이다.
        result = 0
        for idx, val in enumerate(tmp):
            if val == 0:
                result += numbers[idx]
            else:
                result -= numbers[idx]
        if result == target: # tmp의 원소를 더하고 뺀 결과가 타겟 넘버일 때!
            cnt += 1
    return cnt
```

교육을 통해 배운 부분집합 구하기를 응용해 보앗다.

위의 코드에서 tmp 부분을 출력해보면 다음과 같다. (numbers의 길이가 6일 때)

[0, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 1, 0, 0, 0, 0]
...

[1, 1, 1, 1, 1, 1]



문제의 카테고리가 DFS/BFS라서 해당 방법으로 어떻게 풀 수 있을지 고민해봤지만, 아직은 잘 모르겠다는 결론에 도달했다. (3월 4일)

대신 두 가지 원소로 이루어진 numbers 길이 만큼의 모든 부분집합을 구하여서 어떤 원소이냐에 따라 numbers의 해당 인덱스의 값을 더해주거나 빼주는 형태로 문제를 풀어 보았다.

예를 들어, 위의 tmp에서 tmp = [0, 1, 0, 0, 0, 0] 인 경우, 0을 +로, 1을 -로 생각하고

0번 인덱스의 값이 0이므로 numbers의 0번 인덱스 값은 더해주고,

1번 인덱스의 값이 1이므로 numbers의 1번 인덱스 값은 빼주고,

2번 인덱스의 값이 0이므로 numbers의 2번 인덱스 값은 더해주고,
...

이런 식으로 반복해 주는 방법이다.

이 아이디어를 읽고 나면 코드를 해석하기는 어렵지 않을 것이다. 그러나 이렇게 풀었을 때 한 가지 마음에 걸리는 것이, DFS, BFS를 이용하지 않았다는 점, 그리고 시간이 너무 오래 걸린다는 점이다. 효율성 테스트가 없어서 통과는 했지만, 너무 오랜 시간이 걸린게 아닌가 걱정이 된다. 다른 사람의 풀이를 복붙하여 결과를 한 번 비교해보자.

**나의 풀이**

| 테스트 1 〉 | 통과 (4414.27ms, 10.1MB) |
| ----------- | ------------------------ |
| 테스트 2 〉 | 통과 (4375.05ms, 10.2MB) |
| 테스트 3 〉 | 통과 (2.98ms, 10.2MB)    |
| 테스트 4 〉 | 통과 (11.91ms, 10.2MB)   |

**다른 사람의 풀이**

| 테스트 1 〉 | 통과 (299.24ms, 10MB)   |
| ----------- | ----------------------- |
| 테스트 2 〉 | 통과 (299.23ms, 10.3MB) |
| 테스트 3 〉 | 통과 (0.49ms, 10.2MB)   |
| 테스트 4 〉 | 통과 (1.70ms, 10.3MB)   |

실행 시간에서 열 배 넘게 차이가 난다. 내 풀이는 모든 경우의 수를 다 고려하기 때문인데, 분명 개선의 여지가 있을 것이다. 추후 DFS와 BFS를 연마한 후 반드시 다시 풀어보자.

